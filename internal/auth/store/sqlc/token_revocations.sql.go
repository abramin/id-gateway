// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: token_revocations.sql

package sqlc

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const getTokenRevocationExpiresAt = `-- name: GetTokenRevocationExpiresAt :one
SELECT expires_at FROM token_revocations WHERE jti = $1
`

func (q *Queries) GetTokenRevocationExpiresAt(ctx context.Context, jti string) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getTokenRevocationExpiresAt, jti)
	var expires_at time.Time
	err := row.Scan(&expires_at)
	return expires_at, err
}

const upsertTokenRevocation = `-- name: UpsertTokenRevocation :exec
INSERT INTO token_revocations (jti, expires_at)
VALUES ($1, $2)
ON CONFLICT (jti) DO UPDATE SET
    expires_at = EXCLUDED.expires_at
`

type UpsertTokenRevocationParams struct {
	Jti       string
	ExpiresAt time.Time
}

func (q *Queries) UpsertTokenRevocation(ctx context.Context, arg UpsertTokenRevocationParams) error {
	_, err := q.db.ExecContext(ctx, upsertTokenRevocation, arg.Jti, arg.ExpiresAt)
	return err
}

const upsertTokenRevocations = `-- name: UpsertTokenRevocations :exec
INSERT INTO token_revocations (jti, expires_at)
SELECT unnest($1::text[]), $2
ON CONFLICT (jti) DO UPDATE SET
    expires_at = EXCLUDED.expires_at
`

type UpsertTokenRevocationsParams struct {
	Column1   []string
	ExpiresAt time.Time
}

func (q *Queries) UpsertTokenRevocations(ctx context.Context, arg UpsertTokenRevocationsParams) error {
	_, err := q.db.ExecContext(ctx, upsertTokenRevocations, pq.Array(arg.Column1), arg.ExpiresAt)
	return err
}
