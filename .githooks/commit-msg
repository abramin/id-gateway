#!/usr/bin/env bash
set -euo pipefail

msg_file="${1:-}"
if [[ -z "$msg_file" || ! -f "$msg_file" ]]; then
  echo "commit-msg hook: missing commit message file."
  exit 1
fi

# Get first non-comment line (commit subjects are on line 1, but be defensive)
subject="$(grep -vE '^\s*#' "$msg_file" | head -n 1 | tr -d '\r')"

# Allow empty (rare) or system-generated commits
if [[ -z "$subject" ]]; then
  exit 0
fi

# Allow merges/reverts without enforcement
if [[ "$subject" =~ ^Merge\  ]] || [[ "$subject" =~ ^Revert\  ]]; then
  exit 0
fi

# Allowed types (extend if you want)
types_regex='feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert|observ|llm'

# Enforce Conventional Commits header:
# type(scope optional): space summary
header_regex="^(${types_regex})(\\([a-zA-Z0-9._/-]+\\))?:\\ [^ ].+"

if ! [[ "$subject" =~ $header_regex ]]; then
  echo "❌ Invalid commit subject."
  echo "Expected: type(scope): summary"
  echo "Examples:"
  echo "  feat(auth): rotate refresh tokens (#1)"
  echo "  refactor(pkg/http): simplify middleware chain"
  echo "Allowed types: ${types_regex}"
  exit 1
fi

# If feat/fix, require issue reference in commit message
# Accepts: #1, #123, (#1), Closes #1, Fixes #123, Refs #1, etc.
commit_content="$(cat "$msg_file")"
issue_regex='#[0-9]+'

if [[ "$subject" =~ ^(feat|fix) ]] && ! [[ "$commit_content" =~ $issue_regex ]]; then
  echo "❌ feat/fix commits must reference a GitHub issue."
  echo "Add an issue reference like: #1, Closes #1, Fixes #123"
  echo "Examples:"
  echo "  feat(auth): add device-bound refresh tokens (#1)"
  echo "  feat(registry): citizen lookup"
  echo ""
  echo "  Closes #1"
  exit 1
fi

exit 0
